/// Signifies a placeholder variable which is later converted into an actual value.
/// These placeholders are necessary to handle constructs such as recirculation or cloning.
class Placeholder : Expression {
#noconstructor

    /// The label of the placeholder.
    cstring label;

    /// The default value of the placeholder.
    IR::Expression defaultValue;

    /// A symbolic variable always has a default value, and no source info.
    Placeholder(cstring label, Expression defaultValue) : Expression(defaultValue->type), label(label), defaultValue(defaultValue) {}

    /// Implements comparisons so that Placeholders can be used as map keys.
    /// The default value is ignored.
    bool operator<(const Placeholder &other) const {
        return label < other.label;
    }

    toString { return "@" + label +"(" + type->toString() + ")@"; }

    dbprint { out << "@" + label +"(" << type << ")@"; }
}


/// An extension of a struct expression. Also tracks validity as an expression.
class HeaderExpression : StructExpression {
    /// Whether this struct expression is valid. Mostly relevant to header expressions.
    Expression validity;

    dbprint {
        out << "(" << validity << "){" << IndentCtl::indent;
        for (auto &field : components) out << Log::endl << field << ';';
        out << " }" << IndentCtl::unindent;
    }

    validate {
        components.check_null(); components.validate();
        BUG_CHECK(structType == nullptr || structType->is<IR::Type_Header>(), "%1%: unexpected header type", structType->node_type_name());
    }
}
