/// Signifies a placeholder variable which is later converted into an actual value.
/// These placeholders are necessary to handle constructs such as recirculation or cloning.
class Placeholder : Expression {
#noconstructor

    /// The label of the placeholder.
    cstring label;

    /// The default value of the placeholder.
    Expression defaultValue;

    /// A symbolic variable always has a default value, and no source info.
    Placeholder(cstring label, Expression defaultValue) : Expression(defaultValue->type), label(label), defaultValue(defaultValue) {}

    /// Implements comparisons so that Placeholders can be used as map keys.
    /// The default value is ignored.
    bool operator<(const Placeholder &other) const {
        return label < other.label;
    }

    toString { return "@" + label +"(" + type->toString() + ")@"; }

    dbprint { out << "@" + label +"(" << type << ")@"; }
}

/// An wrapper which models an InOut argument.
/// Contains both a copy of the original reference as well as the resolved value of that reference.
class InOutReference : Expression {
/// Because we do not use a reference we need to construct the value normally.
#noconstructor
#nomethod_constructor
    /// The original reference.
    inline StateVariable ref;
    /// The value of the reference after it was resolved.
    Expression resolvedRef;

    InOutReference(JSONLoader & json) : Expression(json), ref(json) {
        json.load("resolvedRef", resolvedRef);
    }

    InOutReference(Util::SourceInfo srcInfo, IR::StateVariable &ref, const Expression* resolvedRef) :
        Expression(srcInfo, ref.type), ref(ref), resolvedRef(resolvedRef)
        { validate(); }

    InOutReference(IR::StateVariable &ref, const Expression* resolvedRef) :
        Expression(ref.type), ref(ref), resolvedRef(resolvedRef)
        { validate(); }

    toString { return resolvedRef->toString() + "(" + ref->toString() + ")"; }

    dbprint { out << resolvedRef << "(" << ref << ")"; }
}
